/*
 Navicat Premium Data Transfer

 Source Server         : mage
 Source Server Type    : MySQL
 Source Server Version : 50730
 Source Host           : 192.168.56.101:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50730
 File Encoding         : 65001

 Date: 10/08/2020 09:48:13
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for hibernate_sequence
-- ----------------------------
DROP TABLE IF EXISTS `hibernate_sequence`;
CREATE TABLE `hibernate_sequence`  (
  `next_val` bigint(20) NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of hibernate_sequence
-- ----------------------------
INSERT INTO `hibernate_sequence` VALUES (107);
INSERT INTO `hibernate_sequence` VALUES (107);
INSERT INTO `hibernate_sequence` VALUES (107);
INSERT INTO `hibernate_sequence` VALUES (107);
INSERT INTO `hibernate_sequence` VALUES (107);

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) NOT NULL,
  `appreciation` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_time` datetime(6) NULL DEFAULT NULL,
  `first_pictures` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `update_time` datetime(6) NULL DEFAULT NULL,
  `views` int(11) NULL DEFAULT NULL,
  `type_id` bigint(20) NULL DEFAULT NULL,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (85, b'1', b'1', '### 1.Lambda简介\r\n\r\nLambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。\r\n\r\nJDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 0:05\r\n */\r\npublic class MyLambda {\r\n    public static void main(String[] args) {\r\n        //方式一实现\r\n        Person person= new Student();\r\n        int compare = person.compare(3, 2);\r\n        System.out.println(compare);\r\n        //方式二：匿名内部类\r\n        Person person1 = new Person() {\r\n            @Override\r\n            public int compare(int a, int b) {\r\n                return a-b;\r\n            }\r\n        };\r\n        System.out.println(person1.compare(5,4));\r\n        //方式三：Lambda\r\n        Person person2 =(a,b)-> a-b;\r\n        System.out.println(person2.compare(4,5));\r\n    }\r\n}\r\n//接口实现类\r\nclass Student implements Person{\r\n    @Override\r\n    public int compare(int a, int b) {\r\n        return a-b;\r\n    }\r\n}\r\n//接口\r\ninterface Person{\r\n    int compare(int a,int b);\r\n}\r\n```\r\n\r\n### 2.Lambda对接口的要求\r\n\r\n虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。**Lambda 规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法**\r\n\r\n> jdk 8 中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。\r\n\r\n### @FunctionalInterface\r\n\r\n修饰函数式接口的，要求接口中的抽象方法只有一个。 这个注解往往会和 lambda 表达式一起出现。\r\n\r\n### 3.Lambda 基础语法\r\n\r\n我们这里给出六个接口，后文的全部操作都利用这六个接口来进行阐述。\r\n\r\n```java\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:03\r\n */\r\n/**多参数无返回*/\r\n@FunctionalInterface\r\npublic interface NoReturnMultiParam {\r\n    void method(int a, int b);\r\n}\r\n\r\n/**无参无返回值*/\r\n@FunctionalInterface\r\npublic interface NoReturnNoParam {\r\n    void method();\r\n}\r\n\r\n/**一个参数无返回*/\r\n@FunctionalInterface\r\npublic interface NoReturnOneParam {\r\n    void method(int a);\r\n}\r\n\r\n/**多个参数有返回值*/\r\n@FunctionalInterface\r\npublic interface ReturnMultiParam {\r\n    int method(int a, int b);\r\n}\r\n\r\n/*** 无参有返回*/\r\n@FunctionalInterface\r\npublic interface ReturnNoParam {\r\n    int method();\r\n}\r\n\r\n/**一个参数有返回值*/\r\n@FunctionalInterface\r\npublic interface ReturnOneParam {\r\n    int method(int a);\r\n}\r\n```\r\n\r\n`语法形式为 () -> {}，其中 () 用来描述参数列表，{} 用来描述方法体，-> 为 lambda运算符 ，读作(goes to)。`\r\n\r\n```java\r\nimport lambda.interfaces.*;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:03\r\n */\r\npublic class Test1 {\r\n    public static void main(String[] args) {\r\n\r\n        //无参无返回\r\n        NoReturnNoParam noReturnNoParam = () -> {\r\n            System.out.println(\"NoReturnNoParam\");\r\n        };\r\n        noReturnNoParam.method();\r\n\r\n        //一个参数无返回\r\n        NoReturnOneParam noReturnOneParam = (int a) -> {\r\n            System.out.println(\"NoReturnOneParam param:\" + a);\r\n        };\r\n        noReturnOneParam.method(6);\r\n\r\n        //多个参数无返回\r\n        NoReturnMultiParam noReturnMultiParam = (int a, int b) -> {\r\n            System.out.println(\"NoReturnMultiParam param:\" + \"{\" + a +\",\" + + b +\"}\");\r\n        };\r\n        noReturnMultiParam.method(6, 8);\r\n\r\n        //无参有返回值\r\n        ReturnNoParam returnNoParam = () -> {\r\n            System.out.print(\"ReturnNoParam\");\r\n            return 1;\r\n        };\r\n\r\n        int res = returnNoParam.method();\r\n        System.out.println(\"return:\" + res);\r\n\r\n        //一个参数有返回值\r\n        ReturnOneParam returnOneParam = (int a) -> {\r\n            System.out.println(\"ReturnOneParam param:\" + a);\r\n            return 1;\r\n        };\r\n\r\n        int res2 = returnOneParam.method(6);\r\n        System.out.println(\"return:\" + res2);\r\n\r\n        //多个参数有返回值\r\n        ReturnMultiParam returnMultiParam = (int a, int b) -> {\r\n            System.out.println(\"ReturnMultiParam param:\" + \"{\" + a + \",\" + b +\"}\");\r\n            return 1;\r\n        };\r\n\r\n        int res3 = returnMultiParam.method(6, 8);\r\n        System.out.println(\"return:\" + res3);\r\n    }\r\n}\r\n```\r\n\r\n### 5.Lambda 语法简化\r\n\r\n我们可以通过观察以下代码来完成代码的进一步简化，写出更加优雅的代码.\r\n\r\n```java\r\nimport lambda.interfaces.*;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:03\r\n */\r\npublic class Test2 {\r\n    public static void main(String[] args) {\r\n\r\n        //1.简化参数类型，可以不写参数类型，但是必须所有参数都不写\r\n        NoReturnMultiParam lamdba1 = (a, b) -> {\r\n            System.out.println(\"简化参数类型\");\r\n        };\r\n        lamdba1.method(1, 2);\r\n\r\n        //2.简化参数小括号，如果只有一个参数则可以省略参数小括号\r\n        NoReturnOneParam lambda2 = a -> {\r\n            System.out.println(\"简化参数小括号\");\r\n        };\r\n        lambda2.method(1);\r\n\r\n        //3.简化方法体大括号，如果方法条只有一条语句，则可以省略方法体大括号\r\n        NoReturnNoParam lambda3 = () -> System.out.println(\"简化方法体大括号\");\r\n        lambda3.method();\r\n\r\n        //4.如果方法体只有一条语句，并且是 return 语句，则可以省略方法体大括号和return关键字\r\n        ReturnOneParam lambda4 = a -> a+3;\r\n        System.out.println(lambda4.method(5));\r\n\r\n        ReturnMultiParam lambda5 = (a, b) -> a+b;\r\n        System.out.println(lambda5.method(1, 1));\r\n    }\r\n}\r\n```\r\n\r\n### 6.Lambda 表达式常用示例\r\n\r\n- **lambda 表达式引用方法**\r\n\r\n有时候我们不是必须要自己重写某个匿名内部类的方法，我们可以可以利用 lambda表达式的接口快速指向一个已经被实现的方法。\r\n\r\n**语法**\r\n\r\n `方法归属者::方法名 静态方法的归属者为类名，普通方法归属者为对象`\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:03\r\n */\r\n//函数式接口\r\n@FunctionalInterface\r\npublic interface ReturnOneParam {\r\n    public int method(int a);\r\n}\r\n```\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:02\r\n */\r\npublic class Exe {\r\n    public static void main(String[] args) {\r\n        //最原始的Lambda方式实现接口方法\r\n        ReturnOneParam lambda = a -> a*2;\r\n        System.out.println(lambda.method(3));\r\n\r\n	//方法的引用：可以快速的将一个Lambda的实现直接指向一个已经实现的方法（也就是被static修饰的方法）\r\n        ReturnOneParam lambda1 = a -> doubleNum(a);\r\n        System.out.println(lambda1.method(3));\r\n\r\n        //lambda2 引用了已经实现的 doubleNum 方法\r\n        ReturnOneParam lambda2 = Exe::doubleNum;\r\n        System.out.println(lambda2.method(3));\r\n\r\n        Exe exe = new Exe();\r\n\r\n        //lambda4 引用了已经实现的 addTwo 方法\r\n        ReturnOneParam lambda4 = exe::addTwo;\r\n        System.out.println(lambda4.method(2));\r\n    }\r\n\r\n    /**\r\n     * 要求\r\n     * 1.参数数量和类型要与接口中定义的一致\r\n     * 2.返回值类型要与接口中定义的一致\r\n     */\r\n    public static int doubleNum(int a) {\r\n        return a * 2;\r\n    }\r\n\r\n    public int addTwo(int a) {\r\n        return a + 2;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- **构造方法的引用**\r\n\r\n一般我们需要声明接口，该接口作为对象的生成器，通过 类名::new 的方式来实例化对象，然后调用方法返回对象。\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:43\r\n */\r\npublic class Item {\r\n    private int id;\r\n    private String name;\r\n    private double price;\r\n\r\n    public Item() {\r\n        System.out.println(\"无参构造函数被调用\");\r\n    }\r\n\r\n    public Item(int id, String name, double price) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.price = price;\r\n        System.out.println(\"有参构造函数被调用\");\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public double getPrice() {\r\n        return price;\r\n    }\r\n\r\n    public void setPrice(double price) {\r\n        this.price = price;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Item{\" +\r\n                \"id=\" + id +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \", price=\" + price +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 9:42\r\n */\r\ninterface ItemCreatorBlankConstruct {\r\n    Item getItem();\r\n}\r\ninterface ItemCreatorParamContruct {\r\n    Item getItem(int id, String name, double price);\r\n}\r\n\r\npublic class Exe2 {\r\n    public static void main(String[] args) {\r\n        ItemCreatorBlankConstruct creator = () -> new Item();\r\n        Item item = creator.getItem();\r\n        System.out.println(item);\r\n\r\n        ItemCreatorBlankConstruct creator2 = Item::new;\r\n        Item item2 = creator2.getItem();\r\n        System.out.println(item2);\r\n\r\n        ItemCreatorParamContruct creator3 = Item::new;\r\n        Item item3 = creator3.getItem(112, \"鼠标\", 135.99);\r\n        System.out.println(item3);\r\n    }\r\n}\r\n```\r\n\r\n- **lambda 表达式创建线程**\r\n\r\n我们以往都是通过创建 Thread 对象，然后通过匿名内部类重写 run() 方法，一提到匿名内部类我们就应该想到可以使用 lambda 表达式来简化线程的创建过程。\r\n\r\n```java\r\npackage com.mage.state;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-22 21:09\r\n */\r\npublic class Testyield1 {\r\n    public static void main(String[] args) {\r\n        new Thread(()->{\r\n            for (int i = 0; i < 100; i++) {\r\n                System.out.println(\"lanbda....\"+i);\r\n            }\r\n        }).start();\r\n        for (int i = 0; i < 200; i++) {\r\n            System.out.println(\"main方法\"+i);\r\n            if(i%3==0){\r\n               Thread.yield();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n- **集合排序遍历**\r\n\r\n  对于某些集合排序，按照key递增的方式排序，对于自定义的排序，需要实现接口Comparable<T>，极大的不方便，而Lambda表达式可以很方便的解决这个问题，我们可以来如下代码：\r\n\r\n  **方式一：**实现接口Compable<T>\r\n\r\n```java\r\npackage com.map;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-22 16:45\r\n */\r\npublic class Emp implements Comparable<Emp>{\r\n    private Integer age;\r\n    private String name;\r\n    private double salery;\r\n\r\n    public Emp(Integer age, String name, double salery) {\r\n        this.age = age;\r\n        this.name = name;\r\n        this.salery = salery;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public double getSalery() {\r\n        return salery;\r\n    }\r\n\r\n    public void setSalery(double salery) {\r\n        this.salery = salery;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Emp{\" +\r\n                \"age=\" + age +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \", salery=\" + salery +\r\n                \'}\';\r\n    }\r\n\r\n    //小于，返回-1；等于，返回0；大于，返回+1；\r\n    @Override\r\n    public int compareTo(Emp o) {\r\n        if(this.salery>o.salery){\r\n            return 1;\r\n        }else if(this.salery<o.salery){\r\n            return -1;\r\n        }else {\r\n            if(this.age>o.age){\r\n                return 1;\r\n            }else if(this.age<o.age){\r\n                return -1;\r\n            }else {\r\n                return 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.map;\r\n\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-22 16:43\r\n */\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        //Arraylist集合\r\n        List<Emp> emps1 = new ArrayList<>();\r\n        emps1.add(new Emp(25,\"张三\",10000));\r\n        emps1.add(new Emp(26,\"qzp\",10000));\r\n        emps1.add(new Emp(30,\"李四\",18000));\r\n        emps1.add(new Emp(35,\"王二\",20000));\r\n        //遍历\r\n        for(Emp ss:emps1){\r\n            System.out.println(ss);\r\n        }\r\n        //TreeSet集合\r\n        //自定义主键，想要按照key递增的方式排序，需要用比较器，实现接口Comparable<T>\r\n        Set<Emp> emps2 = new TreeSet<>();\r\n        emps2.add(new Emp(25,\"张三\",10000));\r\n        emps2.add(new Emp(26,\"qzp\",10000));\r\n        emps2.add(new Emp(30,\"李四\",18000));\r\n        emps2.add(new Emp(35,\"王二\",20000));\r\n        //遍历\r\n        for(Emp ss:emps2){\r\n            System.out.println(ss);\r\n        }\r\n        //TreeMap集合\r\n        Map<Integer,String> treeMap1 = new TreeMap<>();\r\n        treeMap1.put(20,\"aa\");\r\n        treeMap1.put(30,\"cc\");\r\n        treeMap1.put(40,\"dd\");\r\n        //按照key递增的方式排序\r\n        for(Integer key:treeMap1.keySet()){\r\n            System.out.println(key+\"--->\"+treeMap1.get(key));\r\n        }\r\n        //自定义主键，想要按照key递增的方式排序，需要用比较器，实现接口Comparable<T>\r\n        Map<Emp, String> treeMap2 = new TreeMap<>();\r\n        treeMap2.put(new Emp(25,\"张三\",10000),\"张三是一个好小伙\");\r\n        treeMap2.put(new Emp(26,\"qzp\",10000),\"qzp是一个好小伙\");\r\n        treeMap2.put(new Emp(30,\"李四\",18000),\"李四是一个积极向上小伙\");\r\n        treeMap2.put(new Emp(35,\"王二\",20000),\"王二是一个好项目经理\");\r\n        for(Emp emp:treeMap2.keySet()){\r\n            System.out.println(emp);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**方式二：Lambda表达式**\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-22 17:46\r\n */\r\nclass Person1 {\r\n    private Integer age;\r\n    private String name;\r\n    private double salery;\r\n\r\n    public Person1(Integer age, String name, double salery) {\r\n        this.age = age;\r\n        this.name = name;\r\n        this.salery = salery;\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public double getSalery() {\r\n        return salery;\r\n    }\r\n\r\n    public void setSalery(double salery) {\r\n        this.salery = salery;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person1{\" +\r\n                \"age=\" + age +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \", salery=\" + salery +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.mage;\r\nimport java.util.ArrayList;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 10:08\r\n */\r\npublic class Exe3 {\r\n    public static void main(String[] args) {\r\n        //ArrayList集合遍历排序\r\n        ArrayList<Person1> list = new ArrayList<>();\r\n\r\n        list.add(new Person1(25,\"张三\",10000));\r\n        list.add(new Person1(26,\"qzp\",10000));\r\n        list.add(new Person1(30,\"李四\",18000));\r\n        list.add(new Person1(35,\"王二\",20000));\r\n        //降序(调用函数式接口Comparator<T>)\r\n        list.sort((o1, o2) -> o2.getAge() - o1.getAge());\r\n        System.out.println(list);\r\n        \r\n        //TreeSet集合遍历排序\r\n        TreeSet<Person1> treeSet = new TreeSet<>((o1, o2) -> {\r\n            if(o1.getSalery()>o2.getSalery()){\r\n                return 1;\r\n            }else if(o1.getSalery()<o2.getSalery()){\r\n                return -1;\r\n            }else {\r\n                if(o1.getAge()>o2.getAge()){\r\n                    return 1;\r\n                }else if(o1.getAge()<o2.getAge()){\r\n                    return -1;\r\n                }else {\r\n                    return 0;\r\n                }\r\n            }\r\n        });\r\n        treeSet.add(new Person1(25,\"张三\",10000));\r\n        treeSet.add(new Person1(26,\"qzp\",10000));\r\n        treeSet.add(new Person1(30,\"李四\",18000));\r\n        treeSet.add(new Person1(35,\"王二\",20000));\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n```\r\n\r\n- **遍历集合**\r\n\r\n我们可以调用集合的 `public void forEach(Consumer<? super E> action)` 方法，通过 lambda 表达式的方式遍历集合中的元素。以下是 Consumer 接口的方法以及遍历集合的操作。Consumer 接口是 jdk 为我们提供的一个函数式接口。\r\n\r\n```java\r\n@FunctionalInterface\r\npublic interface Consumer<T> {\r\n    void accept(T t);\r\n    //....\r\n}\r\n```\r\n\r\n```java\r\npackage com.mage;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 12:13\r\n */\r\npublic class Exe4 {\r\n    public static void main(String[] args) {\r\n        ArrayList<Integer> list = new ArrayList<>();\r\n        //注意：Collections是一个工具类，不是接口\r\n        Collections.addAll(list, 1,2,3,4,5);\r\n\r\n        list.forEach(x -> {\r\n            System.out.println(x);\r\n        });\r\n        //lambda表达式 方法引用\r\n        list.forEach(System.out::println);\r\n        //添加条件输出\r\n        list.forEach(element -> {\r\n            if (element % 2 == 0) {\r\n                System.out.println(element);\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n- **删除集合中的某个元素**\r\n\r\n我们通过`public boolean removeIf(Predicate<? super E> filter)`方法来删除集合中的某个元素，Predicate 也是 jdk 为我们提供的一个函数式接口，可以简化程序的编写。\r\n\r\n```java\r\nArrayList<Item> items = new ArrayList<>();\r\nitems.add(new Item(11, \"小牙刷\", 12.05 ));\r\nitems.add(new Item(5, \"日本马桶盖\", 999.05 ));\r\nitems.add(new Item(7, \"格力空调\", 888.88 ));\r\nitems.add(new Item(17, \"肥皂\", 2.00 ));\r\nitems.add(new Item(9, \"冰箱\", 4200.00 ));\r\n\r\nitems.removeIf(ele -> ele.getId() <7);\r\n\r\n//通过 foreach 遍历，查看是否已经删除\r\nitems.forEach(System.out::println);\r\n```\r\n\r\n- **集合内元素的排序**\r\n\r\n在以前我们若要为集合内的元素排序，就必须调用 sort 方法，传入比较器匿名内部类重写 compare 方法，我们现在可以使用 lambda 表达式来简化代码。\r\n\r\n```java\r\nArrayList<Item> list = new ArrayList<>();\r\nlist.add(new Item(13, \"背心\", 7.80));\r\nlist.add(new Item(11, \"半袖\", 37.80));\r\nlist.add(new Item(14, \"风衣\", 139.80));\r\nlist.add(new Item(12, \"秋裤\", 55.33));\r\n\r\n/*\r\nlist.sort(new Comparator<Item>() {\r\n    @Override\r\n    public int compare(Item o1, Item o2) {\r\n    	return o1.getId()  - o2.getId();\r\n	}\r\n});\r\n*/\r\n\r\nlist.sort((o1, o2) -> o1.getId() - o2.getId());\r\n\r\nSystem.out.println(list);\r\n```\r\n\r\n### 7.Lambda 表达式中的闭包问题\r\n\r\n这个问题我们在匿名内部类中也会存在，如果我们把注释放开会报错，告诉我 num 值是被 final 修饰了，不能被改变。这里我们虽然没有标识 num 类型为 final，但是在编译期间虚拟机会帮我们加上 final 修饰关键字。\r\n\r\n```java\r\nimport java.util.function.Consumer;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-23 12:13\r\n */\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n\r\n        int num = 10;\r\n\r\n        Consumer<String> consumer = ele -> {\r\n            System.out.println(num);\r\n        };\r\n\r\n        //num = num + 2;\r\n        consumer.accept(\"hello\");\r\n    }\r\n}\r\n```\r\n\r\n', '2020-07-16 18:11:55.904000', 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1235112269,2241775974&fm=26&gp=0.jpg', '原创', b'0', b'1', b'1', 'Lambda表达式详解', '2020-07-19 17:28:29.651000', 4, 84, 1, 'Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。');
INSERT INTO `t_blog` VALUES (86, b'1', b'1', '### Node节点的重要性\r\n\r\n- 每一个链表实际上就是有多个节点所组成，链表就好比火车，都是有一节一节的车厢组成，每一节车厢，既可以载乘客，也提示了下一节车厢和上一节车厢的信息，这就好比是Node，不仅仅是为了保存数据，也是为了保存下/上一个节点的信息，另外，保存的数据，没有办法保存下一个节点的信息，就单单是一个数据，同时，数据的保存，也需要一个包装类来保存。这个时候，Node的重要性就脱颖而出了。可以参考一下代码来思考：\r\n\r\n```java\r\npackage com.node;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-21 0:48\r\n */\r\n//每一个链表实际上就是有多个节点所组成\r\nclass Node {//定义一个节点\r\n    private String data;//要保存的数据\r\n    private Node next;//要保存的下一个节点\r\n    //每一个Node类对象都要保存有相应的数据\r\n    public Node(String data) {//必须有数据才能Node\r\n        this.data = data;\r\n    }\r\n    public void setNext(Node next){\r\n        this.next = next;\r\n    }\r\n    public Node getNext(){\r\n        return this.next;\r\n    }\r\n    public String getData(){\r\n        return this.data;\r\n    }\r\n}\r\nclass LinkDemo{\r\n    public static void main(String[] args) {\r\n        //第一步，准备取出所有数据\r\n        Node root = new Node(\"火车头\");\r\n        Node s1 = new Node(\"车厢A\");\r\n        Node s2 = new Node(\"车厢B\");\r\n        root.setNext(s1);\r\n        s1.setNext(s2);\r\n        test(root);\r\n       /* System.out.println(root.getData());\r\n        System.out.println(s1.getData());\r\n        System.out.println(s2.getData());*/\r\n    }\r\n    public static  void test(Node node){\r\n        if(node == null){\r\n            return;\r\n        }\r\n        System.out.println(node.getData());\r\n        test(node.getNext());\r\n    }\r\n}\r\n```\r\n\r\n### 1.手写代码实现ArrayList集合\r\n\r\n```java\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-20 21:48\r\n */\r\npublic class MyArrayList {\r\n    //存储数据的数组\r\n    private Object[] elementDate;\r\n    //存储数据的个数\r\n    private int size;\r\n    //数组的长度\r\n    private static final int DEFAULT_CAPACITY=10;\r\n\r\n    public MyArrayList() {\r\n        elementDate = new Object[DEFAULT_CAPACITY];\r\n    }\r\n    //数据超过默认值时\r\n    public MyArrayList(int capacity) {\r\n        if(capacity<0){\r\n            throw new RuntimeException(\"容器的容量不能设为负值\");\r\n        }else if(capacity==0){\r\n            elementDate = new Object[DEFAULT_CAPACITY];\r\n        }else {\r\n            elementDate = new Object[capacity];\r\n        }\r\n    }\r\n    /**\r\n     * 返回list大小 size()\r\n     * 返回SxtArrayList对象大小即SxtArrayList中数组大小\r\n     */\r\n    public int size(){\r\n        return size;\r\n    }\r\n    /**\r\n     * 判断list是否为空 isEmpty() 此方法待改进 初始化时并未使用size 只有add时候用到size属性 直接判断size不正确\r\n     * 返回SxtArrayList对象是否为空即SxtArrayList中数组中是否有实际值\r\n     */\r\n    public boolean isEmpty(){\r\n        return size == 0;\r\n    }\r\n    /**\r\n     * 删除指定位置对象 remove(int index)\r\n     * rangeCheck(index)检验数组下标是否越界\r\n     * 删除对象前计算出要删除的对象后面还剩多少对象以便于后面元素向前移动\r\n     * 移动对象\r\n     * 原数组最后一位设置为空\r\n     * 如果删除对象在数组最后一位则直接删除无需数组元素移动\r\n     * 返回 null\r\n     */\r\n    public void remove(int index){\r\n        rangeCheck(index);\r\n        int numMove = size - index -1;\r\n        if(numMove > 0) {\r\n            //第一个是要复制的数组，第二个是从要复制的数组的第几个开始，\r\n            //第三个是复制到那，四个是复制到的数组第几个开始，最后一个是复制长度\r\n            System.arraycopy(elementDate, index + 1, elementDate, index, numMove);\r\n        }\r\n        elementDate[--size] = null;\r\n    }\r\n    /**\r\n     * 删除指定对象 remove(Object obj)\r\n     * 判断传入对象是否存在\r\n     * 如果存在则会得到相应下标位置\r\n     * 利用下标位置删除此元素\r\n     * 返回 null\r\n     */\r\n    public void remove(Object obj){\r\n        for(int i=0;i<size;i++){\r\n            if(getIndex(i).equals(obj)){//底层是equls\r\n                remove(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    //添加数据\r\n    private void add(Object object){\r\n        //扩容\r\n        if(size==elementDate.length){\r\n            Object[] newArray = new Object[elementDate.length+(elementDate.length>>1)];\r\n            System.arraycopy(elementDate,0,newArray,0,elementDate.length);\r\n            elementDate = newArray;\r\n        }\r\n        elementDate[size++] = object;\r\n    }\r\n    //根据索引取值\r\n    public Object getIndex(int index){\r\n        rangeCheck(index);\r\n        return elementDate[index];\r\n    }\r\n    //根据索引修改值\r\n    public void setIndex(int index,Object object){\r\n        //检查索引\r\n        rangeCheck(index);\r\n        elementDate[index]=object;\r\n    }\r\n    /**\r\n     * 检验数组下标是否越界\r\n     */\r\n    private void rangeCheck(int index){\r\n        if(index<0 || index>=size){\r\n            try {\r\n                throw new Exception(\"下标越界\");\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString(){\r\n        StringBuffer sb = new StringBuffer();\r\n        sb.append(\"[\");\r\n        for (int i = 0; i < size; i++) {\r\n            sb.append(elementDate[i]+\",\");\r\n        }\r\n        sb.setCharAt(sb.length()-1,\']\');\r\n        return sb.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        MyArrayList myArrayList = new MyArrayList();\r\n        myArrayList.add(\"abc\");\r\n        System.out.println(myArrayList);\r\n        for (int i = 0; i < 40; i++) {\r\n            myArrayList.add(\"gao\"+i);\r\n        }\r\n        System.out.println(myArrayList);\r\n        final Object index = myArrayList.getIndex(10);\r\n        System.out.println(index);\r\n        System.out.println(myArrayList.size);\r\n        myArrayList.setIndex(1,\"你好\");\r\n        System.out.println(myArrayList);\r\n        myArrayList.remove(2);\r\n        System.out.println(myArrayList);\r\n        myArrayList.remove(\"gao4\");\r\n        System.out.println(myArrayList);\r\n    }\r\n}\r\n```\r\n\r\n### 2.手写代码实现LickedList集合\r\n\r\n```java\r\npackage com.mage;\r\nimport java.util.Map;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-20 23:18\r\n */\r\npublic class Node {\r\n    Node previous;//前一个节点\r\n    Node next;//下一个节点\r\n    Object element;//本节点保存的值\r\n\r\n    public Node(Node previous, Node next, Object element) {\r\n        this.previous = previous;\r\n        this.next = next;\r\n        this.element = element;\r\n    }\r\n\r\n    public Node(Object element) {\r\n        this.element = element;\r\n    }\r\n}\r\n\r\n\r\npackage com.mage;\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-20 23:16\r\n */\r\npublic class MyLickedList {\r\n    private Node first;//第一个节点\r\n    private Node last;//最后一个节点\r\n    private int size;//当前节点个数\r\n\r\n    //增加节点\r\n    private void add(Object object){\r\n        Node node = new Node(object);\r\n        if(first == null){\r\n            node.previous = null;\r\n            node.next = null;\r\n            first = node;\r\n            last = node;\r\n        }else {\r\n            node.previous = last;\r\n            node.next = null;\r\n            last.next = node;\r\n            last = node;\r\n        }\r\n        size++;\r\n    }\r\n    //删除节点值,先要通过索引来查出节点\r\n    public void remove(int index){\r\n        Node temp = getNode(index);\r\n        if(temp != null){\r\n            Node up = temp.previous;\r\n            Node down = temp.next  ;\r\n            if(up !=null){\r\n                up.next = down;\r\n            }\r\n            if (down !=null){\r\n                down.previous = up;\r\n            }\r\n            //被删除第一个节点\r\n            if(index == 0){\r\n                first = down;\r\n            }\r\n            //被删除最后一个节点\r\n            if(index == size-1){\r\n                last = up;\r\n            }\r\n            size--;\r\n        }\r\n    }\r\n    //插入节点\r\n    public void insert(int index,Object object){\r\n        Node newNode = new Node(object);\r\n        Node temp = getNode(index);\r\n        if(temp != null){\r\n            Node up = temp.previous;\r\n            if(up !=null){\r\n                up.next = newNode;\r\n                newNode.previous = up;\r\n                newNode.next = temp;\r\n                temp.previous = newNode;\r\n            }\r\n            size++;\r\n        }\r\n    }\r\n    //根据indes来获取节点\r\n    public Node getNode(int index){\r\n        if(index<0||index>size-1){\r\n            throw new RuntimeException(\"索引不合法\");\r\n        }\r\n        Node temp = null;\r\n        if(index<=(size>>1)){\r\n           temp = first;\r\n            for (int i = 0; i < index; i++) {\r\n                temp = temp.next;\r\n            }\r\n            return temp;\r\n        }else{\r\n           temp = last;\r\n            for (int i = size-1; i > index; i--) {\r\n                temp = temp.previous;\r\n            }\r\n            return temp;\r\n        }\r\n    }\r\n    //获取节点值\r\n    public Object get(int index){\r\n        Node temp = getNode(index);\r\n        /*if(index>(size>>1)){\r\n            Node temp = first;\r\n            for (int i = 0; i < index; i++) {\r\n                temp = temp.next;\r\n            }\r\n            return temp.element;\r\n        }else{\r\n            Node temp = last;\r\n            for (int i = 0; i > index; i--) {\r\n                temp = temp.previous;\r\n            }*/\r\n            return temp!=null?temp.element:null;\r\n    }\r\n    public int size(){\r\n        /*\r\n         * 返回数据对象的个数\r\n         */\r\n        return size;\r\n    }\r\n    //返回节点的所有元素值\r\n    public Object[] toArray(){\r\n        Object[] temp = new Object[size];\r\n        Node node = first;\r\n        for(int i = 0;i < size;i++){\r\n            temp[i] = node.element;\r\n            node = node.next;\r\n        }\r\n        return temp;\r\n    }\r\n    //打印\r\n    @Override\r\n    public String toString(){\r\n        StringBuffer sb = new StringBuffer();\r\n        sb.append(\"[\");\r\n        Node temp = first;\r\n        while (temp != null){\r\n            sb.append(temp.element+\",\");\r\n            temp = temp.next;\r\n        }\r\n       sb.setCharAt(sb.length()-1,\']\');\r\n        return sb.toString();\r\n    }\r\n    public static void main(String[] args) {\r\n        MyLickedList myLickedList = new MyLickedList();\r\n        myLickedList.add(\"a\");\r\n        myLickedList.add(\"b\");\r\n        myLickedList.add(\"c\");\r\n        myLickedList.add(\"d\");\r\n        myLickedList.add(\"e\");\r\n        myLickedList.add(\"f\");\r\n       /* System.out.println(myLickedList);\r\n        System.out.println(myLickedList.get(4));\r\n        myLickedList.remove(0);\r\n        System.out.println(myLickedList);\r\n        myLickedList.remove(4);\r\n        System.out.println(myLickedList);*/\r\n       Object[] all = myLickedList.toArray();\r\n        for (int i = 0; i < all.length; i++) {\r\n            Object o = all[i];\r\n            System.out.print(o+\",\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3.手写代码实现HashMap集合\r\n\r\n```java\r\npackage com.map;\r\n\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-21 15:17\r\n */\r\n//用于MyHashMap中\r\npublic class Node {\r\n    int hash;\r\n    Object key;\r\n    Object value;\r\n    Node next;\r\n\r\n    public Node() {\r\n    }\r\n\r\n    public Node(int hash, Object key, Object value, Node next) {\r\n        this.hash = hash;\r\n        this.key = key;\r\n        this.value = value;\r\n        this.next = next;\r\n    }\r\n}\r\n\r\npackage com.map;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-21 15:16\r\n */\r\npublic class MyHashMap {\r\n    Node[] table;//位桶数组\r\n    int size;//存放的键值对的个数\r\n\r\n    public MyHashMap() {\r\n        table = new Node[16];//长度是默认的，一般是2的整数幂\r\n    }\r\n\r\n    //计算hsah值\r\n    public int myHash(int v,int length){\r\n        System.out.println(\"方式一计算hash\"+v%length);\r\n        System.out.println(\"方式二：\"+(v&(length-1)));\r\n        return v&(length-1);\r\n    }\r\n\r\n    //添加\r\n    public void put(Object key,Object value){\r\n        //定义新的节点\r\n        Node newNode = new Node();\r\n        newNode.hash = myHash(key.hashCode(),table.length);\r\n        newNode.key=key;\r\n        newNode.value=value;\r\n        newNode.next=null;\r\n\r\n        Node temp = table[newNode.hash];\r\n        Node iterLast = null;//正在遍历的最后一个元素\r\n        boolean keyRepeat = false;\r\n        //判断数组中元素是否为空，为空，则直接将新节点放进去\r\n        if(temp==null){\r\n            table[newNode.hash] = newNode;\r\n            size++;\r\n        }else{\r\n            //此处数组不为空，则需要遍历对应的单链表\r\n            while (temp !=null){\r\n                //判断key如果重复，则进行覆盖\r\n                if(temp.key.equals(key)){\r\n                    System.out.println(\"key重复了\");\r\n                    temp.value = value;\r\n                    keyRepeat = true;\r\n                    break;\r\n                }else {\r\n                    //key值不重复，则遍历下一个\r\n                    iterLast = temp;\r\n                    temp=temp.next;\r\n                }\r\n            }\r\n            //添加节点到链表的最后一个\r\n            if(!keyRepeat & iterLast != null){\r\n                iterLast.next = newNode;\r\n                size++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //添加get方法获取value\r\n    public Object get(Object key){\r\n        int hash = myHash(key.hashCode(),table.length);\r\n        Object value = null;\r\n        if(table[hash]!=null){\r\n            Node temp = table[hash];\r\n            while (temp != null){\r\n                if(temp.key.equals(key)){\r\n                    value = temp.value;\r\n                    break;\r\n                }else {\r\n                    temp = temp.next;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    //重写tostring方法\r\n    @Override\r\n    public String toString() {\r\n        StringBuffer sb = new StringBuffer();\r\n        sb.append(\"[\");\r\n        for (int i = 0; i < table.length; i++) {\r\n            Node node = table[i];\r\n            while (node !=null){\r\n                sb.append(node.key+\":\"+node.value+\",\");\r\n                node = node.next;\r\n            }\r\n        }\r\n        sb.setCharAt(sb.length()-1,\']\');\r\n       return sb.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        MyHashMap myHashMap = new MyHashMap();\r\n        myHashMap.put(10,\"aa\");\r\n        myHashMap.put(20,\"bb\");\r\n        myHashMap.put(30,\"cc\");\r\n        myHashMap.put(30,\"mm\");\r\n        myHashMap.put(53,\"bb\");\r\n        myHashMap.put(69,\"cc\");\r\n        myHashMap.put(85,\"mm\");\r\n        System.out.println(myHashMap);\r\n        System.out.println(myHashMap.get(85));\r\n        final Set<String> strings = new HashSet<>();\r\n    }\r\n}\r\n```\r\n\r\n### 4.手写代码实现HashSet集合\r\n\r\n```java\r\npackage com.set;\r\n\r\nimport java.util.HashMap;\r\n\r\n/**\r\n * @param\r\n * @author qzp\r\n * @create 2020-03-22 17:33\r\n */\r\npublic class MyHashSet {\r\n    HashMap map;\r\n\r\n    private static final Object PRESENT = new Object();\r\n\r\n    public MyHashSet() {\r\n        map = new HashMap();\r\n    }\r\n    public int size(){\r\n        return map.size();\r\n    }\r\n    public void add(Object object){\r\n        map.put(object,PRESENT);\r\n    }\r\n    @Override\r\n    public String toString(){\r\n        StringBuffer sb = new StringBuffer();\r\n        sb.append(\"[\");\r\n        for (Object o : map.keySet()) {\r\n            sb.append(o+\",\");\r\n        }\r\n        sb.setCharAt(sb.length()-1,\']\');\r\n        return sb.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final MyHashSet myHashSet = new MyHashSet();\r\n        myHashSet.add(\"aa\");\r\n        myHashSet.add(\"bb\");\r\n        myHashSet.add(\"cc\");\r\n        System.out.println(myHashSet);\r\n    }\r\n}\r\n```\r\n\r\n', '2020-07-16 18:19:24.841000', 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=153310009,752414430&fm=26&gp=0.jpg', '原创', b'1', b'1', b'1', '尝试纯手写java集合类', '2020-07-16 18:19:24.841000', 3, 2, 1, '之前学习java集合类，留下了很多问题，最不明白Node是什么？为什么需要使用它？现在我终于懂了！');
INSERT INTO `t_blog` VALUES (87, b'1', b'1', '### 6.1数组的定义和使用、属性\r\n\r\n#### 6.1.1什么是数组？\r\n\r\n- 数组本质就是用来存储一组数的容器\r\n\r\n#### 6.1.2数组的定义\r\n\r\n- 在java中，数组是一个变量，在内存中开辟一块连续的内存区域，用来存储`相同数据类型`的`有序`集合\r\n  - **相同数据类型**:数组中存储的数据是相同的数据类型数据，不能出现多种数据类型，但是引用类型(Object)除外\r\n  - **有序**:数组存储元素在内存层面上讲是有序的，因为是连续的存储空间；另一方面数组获取值是通过索引去实现，索引也是有序的。\r\n- 数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型\r\n- 数组是引用类型\r\n\r\n#### 6.1.3数组的定义格式\r\n\r\n定义数组的四步法：\r\n\r\n- 声明数组：数据类型[] 变量名；例如：int[]  arrays;\r\n- 分配空间：变量名=new  数据类型[元素个数]; 例如：arrys=new int[6];\r\n- 赋值：变量名[索引]=值; 例如：arrays[0]=2;\r\n- 处理数据：System.out.println(arrays[0]);或者：arrays[0]=arrays[0]*10;\r\n\r\n**tip:声明数组的另一种方式：数据类型  变量名[];（不推荐使用，因为在C#中无法使用第二种声明方式，编译会出错）**\r\n\r\n#### 6.1.4数组的四要素\r\n\r\n- 标识符：数组的名称，用于区分不同的数组\r\n- 数组元素：向数组中存放的数据\r\n- 元素下标（索引）：对数组元素进行编号，从0开始，数组中的每个元素都可以通过下标来访问\r\n- 元素类型：数组元素的数据类型\r\n\r\n#### 6.1.5数组的使用方式\r\n\r\n##### i.第一种方式：动态初始化\r\n\r\n`代码演示：`\r\n\r\n```java\r\nimport java.util.Arrays;\r\npublic class Test1{\r\n    public static void main(String[] args){\r\n        //声明数组并开辟空间\r\n        int[] arrays=new int[5];\r\n        //动态初始化\r\n        arrays[0]=1;\r\n        arrays[1]=2;\r\n        arrays[2]=3;\r\n        arrays[3]=4;\r\n        arrays[4]=5;\r\n        //打印输出数组元素，调用Arrays中的方法\r\n        System.out.println(Arrays.toString(arrays));\r\n    }\r\n}\r\n```\r\n\r\n```\r\n//执行结果：\r\n[1, 2, 1, 2, 1]\r\n```\r\n\r\n**tip:new关键字的含义是在堆内存给数组开辟一块新的连续的存储空间，只要是重新new关键字创建的数组，就会在堆内存中重新开辟新空间**\r\n\r\n##### ii.第二种方式：静态初始化\r\n\r\n`代码演示：`\r\n\r\n```java\r\nimport java.util.Arrays;\r\npublic class Test2{\r\n    public static void main(String[] args){\r\n        //静态初始化方式一\r\n        int[] arrays=new int[]{1,2,3,4,5};\r\n        //打印输出数组元素，调用Arrays中的方法\r\n        System.out.println(Arrays.toString(arrays));\r\n        //静态初始化方式二\r\n        boolean[] arr={true,false};\r\n        System.out.println(Arrays.toString(arr));\r\n    }\r\n}\r\n```\r\n\r\n```\r\n//执行结果：\r\n[1, 2, 3, 4, 5]\r\n[true, false]\r\n```\r\n\r\n#### 6.1.6数组的常见的属性\r\n\r\n##### i.数组length属性\r\n\r\n- 数组在声明赋值时，都需要指定当前数组的长度（也就是元素的个数），通过new关键词在堆内存中开辟好连续的存储空间，我们通过length属性获取当前数组的长度。\r\n\r\n`代码演示：`\r\n\r\n```java\r\npublic class Test3{\r\n	public static void main(String[] args){\r\n		//1：声明一个int类型的数组\r\n		int[] arrs=new int[5];//声明了一个存放5个数据的int类型的数组名字叫arrs\r\n		//2：获取当前数组的长度\r\n		System.out.println(\"获取数组的长度：\"+arrs.length);\r\n    }\r\n}\r\n```\r\n\r\n```\r\n//执行结果：\r\n获取数组的长度：5\r\n```\r\n\r\n##### ii.数组的索引属性\r\n\r\n- 数组中的元素是有序，说的有序称是索引有序。数组中存储的元素，都存在一个下标，我们可以通过下标去获取、修改以及添加元素到数组中去。一定要注意数组的**索引是从0开始的，到length-1结束，故数组的索引范围是是[0,length-1]**\r\n\r\n`代码演示：`\r\n\r\n```java\r\npublic class Test4{\r\n	public static void main(String[] args){\r\n		//1：声明一个int类型的数组，并开辟存储空间\r\n		int[] arrs=new int[5];\r\n        arrs[0]=1;\r\n        arrs[1]=2;\r\n        arrs[2]=3;\r\n        arrs[3]=4;\r\n		//2：获取当前数组的长度\r\n		System.out.println(\"获取数组的长度：\"+arrs.length);\r\n		//3：通过索引获取数组中第4个元素的值\r\n		System.out.println(\"查看数组中第4个元素的值：\"+arrs[3]);\r\n		//4：通过索引改变对应位置上的元素值\r\n		arrs[3]=10;\r\n		System.out.println(\"索引是3的元素，也就是第4个元素的值是：\"+arrs[3]);\r\n		//5:通过索引去添加元素，不能超过数组的元素个数范围\r\n		arrs[4]=5;\r\n		System.out.println(\"查看添加后数组中第5个元素的值：\"+arrs[4]);\r\n    }\r\n}\r\n```\r\n\r\n```\r\n执行结果：\r\n获取数组的长度：5\r\n查看数组中第3个元素的值：4\r\n索引是3的元素，也就是第4个元素的值是：10\r\n查看添加后数组中第5个元素的值：5\r\n```\r\n\r\n#### 6.1.7数组的存储内存分析\r\n\r\n`代码演示：`\r\n\r\n```java\r\npublic class ArraysTest05{\r\n	public static void main(String[] args){\r\n		//1：声明一个存放5个int类型元素的数组\r\n		int[] arrs=new int[5];\r\n		//2:指定数组索引是0的，也就是第一个元素的值是10\r\n		arrs[0]=10;\r\n        System.out.println(\"查看第一个元素的值\"+arrs[0]);\r\n		//3：获取索引是1的，也就是第2个元素的值\r\n		System.out.println(\"查看第2个元素的值是：\"+arrs[1]);\r\n	}\r\n}\r\n```\r\n\r\n```\r\n//执行结果：\r\n查看第一个元素的值10\r\n查看第2个元素的值是：0\r\n```\r\n\r\n想一想，为什么我们没有给数组的第二个元素赋值，怎么会有一个初始值0出来？我们下面就来分析一个数组存储的过程\r\n\r\n![数组内存分析图一](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMTAvMjYvMUNKYnpuZ0VNeXZJVUhmLnBuZw?x-oss-process=image/format,png)\r\n\r\n第一步，创建int数组对象时，内存结构\r\n\r\n- 1>、会在堆内存当中开辟5个长度的连续的存储空间，用来存储int类型的元素。\r\n- 2>、由于当前数组的类型是int类型，所以每个存储空间的元素都是**int的默认值0填充。如果是String类型则默认值为null，就好比类中的不同的数据类型成员变量，对应都会有默认的初始值**\r\n- 3>、将堆内存的地址付给arrs变量存储\r\n\r\n![数组内存分析图二](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMTAvMjYvOHppblV1YUxKZU9CU3Z0LnBuZw?x-oss-process=image/format,png)\r\n\r\n第二步，将索引是1的元素的位置改为10，注意索引是从0开始，length-1结束\r\n\r\n- 在按照元素的索引获取元素值时，注意图中的索引，我们也是按照元素的索引对于数组中的元素进行获取和修改。\r\n\r\n#### 6.1.8为什么数组是不可变的\r\n\r\n当我们将一个数组中的元素添加满了之后，就不能加了，那我们要怎么样去给数组添加长度来满足我们将新的元素添加进去呢？\r\n\r\n`代码演示：`\r\n\r\n```java\r\npublic class ArraysTest05{\r\n	public static void main(String[] args){\r\n		//1：声明一个存放5个int类型元素的数组\r\n		int[] arrs=new int[5];\r\n        //2:指定数组索引是0的，也就是第一个元素的值是10\r\n        arrs[0]=10;\r\n        //3：获取索引是1的，也就是第2个元素的值\r\n        System.out.println(\"查看第2个元素的值是：\"+arrs[1]);\r\n        //4：重新赋值一个新的数组，这里是改变了数组长度吗?\r\n        arrs=new int[7];\r\n        //5：给arrs第6个元素赋值\r\n        arrs[5]=33;\r\n        //6：输出索引是5的元素及第6个元素\r\n        System.out.println(arrs[5]);\r\n    }\r\n}\r\n```\r\n\r\n```\r\n//执行结果：\r\n查看第2个元素的值是：0\r\n33\r\n```\r\n\r\n内存分析：\r\n\r\n![数组长度不可变](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMTAvMjYva2xRU2Nkb3JKZUtnYkJWLnBuZw?x-oss-process=image/format,png)结论：数组一旦声明，其长度是不可变得，我们通常说的改变长度其实都是通过重新定义一个新的数组，改变局部变量的引用而已，将新的地址给给arrs', '2020-07-16 18:31:40.710000', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1594905488809&di=179d2e25f0d937647df92b3ee7d87d97&imgtype=0&src=http%3A%2F%2Ftxt25-2.book118.com%2F2017%2F1015%2Fbook137224%2F137223443.jpg', '原创', b'1', b'1', b'1', 'Java基础知识——数组（一）', '2020-07-19 10:27:24.795000', 12, 2, 1, ' 在java中，数组是一个变量，在内存中开辟一块连续的内存区域，用来存储`相同数据类型`的`有序`集合，数组本质就是用来存储一组数的容器');

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags`  (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  INDEX `FK5feau0gb4lq47fdb03uboswm8`(`tags_id`) USING BTREE,
  INDEX `FKh4pacwjwofrugxa9hpwaxg6mr`(`blogs_id`) USING BTREE,
  CONSTRAINT `FK5feau0gb4lq47fdb03uboswm8` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKh4pacwjwofrugxa9hpwaxg6mr` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES (86, 66);
INSERT INTO `t_blog_tags` VALUES (87, 66);
INSERT INTO `t_blog_tags` VALUES (85, 63);
INSERT INTO `t_blog_tags` VALUES (85, 66);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(6) NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nick_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `blog_id` bigint(20) NULL DEFAULT NULL,
  `parent_comment_id` bigint(20) NULL DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKke3uogd04j4jx316m1p51e05u`(`blog_id`) USING BTREE,
  INDEX `FK4jj284r3pb7japogvo6h72q95`(`parent_comment_id`) USING BTREE,
  CONSTRAINT `FK4jj284r3pb7japogvo6h72q95` FOREIGN KEY (`parent_comment_id`) REFERENCES `t_comment` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (101, '/image/avatar.jpg', '测试评论', '2020-07-19 09:10:29.286000', 'xiaobai@163.com', '小白', 87, NULL, b'0');
INSERT INTO `t_comment` VALUES (102, '/image/avatar.jpg', '测试二级评论', '2020-07-19 09:11:03.818000', 'xiaohong@163.com', '小红', 87, 101, b'0');
INSERT INTO `t_comment` VALUES (103, '/image/avatar.jpg', '测试回复评论', '2020-07-19 09:15:58.596000', 'xiaobai@163.com', '小白', 87, 102, b'0');
INSERT INTO `t_comment` VALUES (104, '/image/avatar.jpg', '我是管理员', '2020-07-19 09:39:17.602000', '2014267082@qq.com', 'qzp', 87, NULL, b'0');
INSERT INTO `t_comment` VALUES (105, 'https://i.loli.net/2020/07/11/EBXfbRhuZHdwcC8.jpg', '我是管理员', '2020-07-19 10:13:53.526000', '2014267082@qq.com', 'qzp', 87, NULL, b'1');
INSERT INTO `t_comment` VALUES (106, 'https://i.loli.net/2020/07/11/EBXfbRhuZHdwcC8.jpg', '我是管理员评论', '2020-07-19 10:14:05.890000', '2014267082@qq.com', 'qzp', 87, 102, b'1');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (42, 'sql');
INSERT INTO `t_tag` VALUES (56, 'mysql');
INSERT INTO `t_tag` VALUES (57, 'redis');
INSERT INTO `t_tag` VALUES (58, '数据库');
INSERT INTO `t_tag` VALUES (59, 'nosql');
INSERT INTO `t_tag` VALUES (60, 'postgresql');
INSERT INTO `t_tag` VALUES (61, 'elasticsearch');
INSERT INTO `t_tag` VALUES (62, 'git');
INSERT INTO `t_tag` VALUES (63, 'github');
INSERT INTO `t_tag` VALUES (64, 'windows');
INSERT INTO `t_tag` VALUES (65, 'vim');
INSERT INTO `t_tag` VALUES (66, 'java');
INSERT INTO `t_tag` VALUES (67, 'noder.js');
INSERT INTO `t_tag` VALUES (68, 'python');
INSERT INTO `t_tag` VALUES (69, 'c++');
INSERT INTO `t_tag` VALUES (70, 'c语言');
INSERT INTO `t_tag` VALUES (71, 'c#');
INSERT INTO `t_tag` VALUES (72, 'spring');
INSERT INTO `t_tag` VALUES (73, 'android');
INSERT INTO `t_tag` VALUES (74, 'ios');
INSERT INTO `t_tag` VALUES (75, '小程序');
INSERT INTO `t_tag` VALUES (76, 'web app');
INSERT INTO `t_tag` VALUES (77, 'javascript');
INSERT INTO `t_tag` VALUES (78, 'css3');
INSERT INTO `t_tag` VALUES (79, 'vue.js');
INSERT INTO `t_tag` VALUES (80, 'html5');
INSERT INTO `t_tag` VALUES (81, 'jquery');
INSERT INTO `t_tag` VALUES (82, 'es6');
INSERT INTO `t_tag` VALUES (83, 'typescript');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (2, 'java');
INSERT INTO `t_type` VALUES (3, 'MySQL');
INSERT INTO `t_type` VALUES (4, 'Spring');
INSERT INTO `t_type` VALUES (5, 'Mybatis');
INSERT INTO `t_type` VALUES (6, 'SpringBoot');
INSERT INTO `t_type` VALUES (10, 'javaWeb');
INSERT INTO `t_type` VALUES (11, '数据结构算法');
INSERT INTO `t_type` VALUES (12, '23种设计模式');
INSERT INTO `t_type` VALUES (13, 'SpringCloud');
INSERT INTO `t_type` VALUES (84, 'Lambda');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(6) NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nick_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `pass_word` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int(11) NULL DEFAULT NULL,
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `update_time` datetime(6) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, 'https://i.loli.net/2020/07/11/EBXfbRhuZHdwcC8.jpg', '2020-07-07 15:33:14.000000', '2014267082@qq.com', 'qzp', '6079781f70437ea01f53a4962e58ad6b', 1, 'quezhipeng', '2020-07-07 15:38:13.000000');

SET FOREIGN_KEY_CHECKS = 1;
